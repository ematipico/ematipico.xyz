[["Map",1,2,9,10,57,58],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.12.9","content-config-digest","6ec701a31bf88521","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://ematipico.xyz\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[\"https://github.com/\"],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":false},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"dracula\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[null,[null,{\"behavior\":\"append\",\"content\":{\"type\":\"text\",\"value\":\"#\"},\"headingProperties\":{\"className\":[\"anchor\"]},\"properties\":{\"className\":[\"anchor-link\"]}}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"rawEnvValues\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"toolchains-the-hard-parts",{"id":11,"data":13,"body":19,"filePath":20,"digest":21,"rendered":22},{"title":14,"description":15,"slug":11,"pubDate":16,"heroImage":17,"heroAltImage":18},"Toolchains, the hard parts","Let's dive inside the hard parts of building a toolchain",["Date","2025-10-10T00:00:00.000Z"],"/src/content/assets/blog/chain.jpg","A chain","## What's a toolchain?\n\nA toolchain is a common term to define software, most of the time a CLI, that provides a set of other tools. \n\nA toolchain that I know about is [`cargo`](https://doc.rust-lang.org/cargo/). `cargo` is the official package manager of the Rust programming language,\nhowever `cargo` provides other features:\n- formatter\n- linter\n- test runner\n- task runner\n- compiler\n- ...and more!\n\nThe other features, **or tools**, are essentially command line tools that are run by `cargo`. I found `cargo` to be very \npowerful, it offers a great developer experience, and it rarely has bugs (that I'm aware of!).\n\nThe perception of toolchain may vary among ecosystems/languages. For example, the JavaScript/TypeScript ecosystem doesn't have a\nproper toolchain like `cargo`, but there are some libraries or frameworks that offer their version of \"unified\" toolchain:\n- For example [NestJs](https://docs.nestjs.com/cli/usages) offers its \"toolchain\" for the framework.\n- Another example is [Astro](https://docs.astro.build/en/reference/cli-reference/), which offers its \"toolchain\" to manage a project.\n- Even [Next.js](https://nextjs.org/docs/pages/api-reference/cli/next) offers a \"toolchain\" to manage the project.\n\n\u003Cimg class=\"prose\" src=\"https://gifdb.com/images/high/new-is-better-barney-stinson-h2b5mmth08rgleij.gif\" alt=\"New is always better\">\n\nHowever, we can see the rise of other software that offers more powerful toolchains:\n- [`Bun`](https://bun.sh/): a runtime that offers a package manager, a bundler, a test runner, a task runner (probably more).\n- [`Deno`](https://deno.com/): a runtime that offers a package manager, a bundler, a test runner, documentation generation, formatter, linter, a language server, a task runner (probably more).\n\nAnd `Node.js` noticed this trend, and it started shipping toolchain capabilities such as test runner - via `node:test` - and a task runner - via `node run`.\n\nI'm generally happy with the trend of the JavaScript/TypeScript ecosystem, and we should keep borrowing ideas from new and modern languages/ecosystems.\n\n## The hard parts \n\nAs maintainer of [Biome](https://biomejs.dev), I've gained experience in how to write toolchains, and if there's\nsomething that isn't easy to get right, it's the developer experience.\n\nContrary to user experience, the developer experience is more subtle to get right because, as a specialist, you provide a tool to your peers who *should have the same level of knowledge*.\n\nUnfortunately, that's not the case. Many of your peers come from different backgrounds and grades of knowledge. Even seniors will need to learn things from scratch. The DX (Developer Experience) of a toolchain must grow\nwith the knowledge acquired by your peers. Your users will always be \"newbies\", and with time they will become proficient with the toolchain.\n\n### Good messages\n\nDX wasn't a thing until ten years ago (more or less), so there wasn't a focus on providing meaningful error messages. Most of the time, it's still like this. \nLet's take, for example, the following JavaScript snippet:\n\n```js\nconst something;\n```\n\nIf you run it in your Browser (I tried Firefox), you'll get the following message:\n\n```\nUncaught SyntaxError: missing = in const declaration\n```\n\nThe message is somewhat understandable. However, I believe that this message is not beginner-friendly. \nLet's see what Biome provides when parsing the same snippet:\n\n```\n at file.js:1:7 parse ━━━━━━━━━━━━━━━━━━━━\n\n  ✖ Const declarations must have an initialized value.\n  \n  > 1 │ const something;\n      │       ^^^^^^^^^\n  \n  ℹ This variable needs to be initialized.\n```\n\nThis message explains that these kinds of declarations must be initialized, and it also shows where the error occurs.\n\nLet's move to another example:\n\n```js\nvar foo = ;\n```\n\nHere's what the browser shows:\n\n```\nUncaught SyntaxError: expected expression, got ';'\n```\n\nAnd here's what Biome outputs:\n\n```\n at file.js:1:11 parse ━━━━━━━━━━━━━━━━━━━━\n\n  ✖ Expected an expression, or an assignment but instead found ';'.\n  \n  > 1 │ var foo = ;\n      │           ^\n  \n  ℹ Expected an expression, or an assignment here.\n  \n  > 1 │ var foo = ;\n      │           ^\n  \n```\n\nI would admit that both messages provide the same level of value: both tell that they expect an expression. It's not very beginner-friendly because the term \"expression\" is very technical. However, it's also challenging to come up with a different message in this situation, especially a synonym for \"expression\".\n\n### Actionable messages\n\nProviding actionable messages isn't something easy to do when parsing broken code, so I will focus on the analysis part of the toolchain.\n\nWhat's an \"actionable message\"? It's a message that should explain to the user how to solve an error. Failing to provide an actionable message would risk making your user stuck, hence degrading the DX level of your toolchain.\n\nLet's take, for example, the rule [`ESlint` `require-await`](https://eslint.org/docs/latest/rules/require-await), and let's compare it to the related [`oxlint` rule](https://oxc.rs/docs/guide/usage/linter/rules/eslint/require-await.html), and the [Biome rule](https://biomejs.dev/linter/rules/use-await/)\n\nWe will lint the following snippet:\n\n```js\nasync function foo() {\n    doSomething();\n}\n```\n\nThis is the default diagnostic that `ESLint` emits for the rule we're interested in:\n\n```\n 1:1   error  Async function 'foo' has no 'await' expression  require-await\n```\n\nThe message tells the user that something is missing, particularly that the code is missing an `await` expression. Expression? Again??  \n\nIt doesn't show where this `foo` function is (maybe another reporter will show that to us), which forces us to check it inside the editor. However, the text `1:1   error` provides a link to the file, which helps.\n\nUnfortunately, the message isn't actionable because it doesn't say how to solve the error. \n\n\n`oxlint`, a younger `ESLint`-compatible linter, takes a better approach: \n\nIt does provide a frame of where the error occurred. Its message is actionable because it provides a tip on how the error could be solved.\n\n```\n  × eslint(require-await): Async function has no 'await' expression.\n   ╭─[file:///Users/ema/www/ematipico.xyz/file.js:1:16]\n 1 │ async function foo() {\n   ·                ───\n 2 │     doSomething();\n   ╰────\n  help: Consider removing the 'async' keyword.\n```\n\n\nBiome, too, provides a good message: \n\n```\n at file.js:1:1 lint/suspicious/useAwait ━━━━━━━━━━━\n\n  ⚠ This async function lacks an await expression.\n  \n  > 1 │ async function foo() {\n      │ ^^^^^^^^^^^^^^^^^^^^^^\n  > 2 │     doSomething();\n  > 3 │ }\n      │ ^\n  \n  ℹ Remove this async modifier, or add an await expression in the function.\n  \n  > 1 │ async function foo() {\n      │ ^^^^^^^^^^^^^^^^^^^^^^\n  > 2 │     doSomething();\n  > 3 │ }\n      │ ^\n  \n  ℹ Async functions without await expressions may not need to be declared async\n```\n\nThe rule also tries to explain why this is an error. It says that if you don't use any `await`, maybe the function shouldn't be `async` at all!\n\nHave you noticed the pattern here? If you haven't, I tell you. `ESLint`, an old tool, still struggles to provide meaningful DX, while younger software such as `oxlint` and `Biome` took the feedback from years of ranting, and elevated the DX to a better quality.\n\n## Everything, out-of-the-box?\n\nA toolchain can have different definitions in different ecosystems; however, nowadays, we're reaching a heterogeneous definition: a toolchain should handle the lifecycle of a project.\n\nBased on the ecosystem, users expect different tools, and we can agree the majority of them require the following (order from most important, to least important, from my point of view):\n1. compiler/build/interpreter\n2. editor support \n3. linter\n4. formatter\n\nLet's see how these tools are distributed.\n\n### Fragmentation\n\nWith the evolution of coding, developers discovered that they require more tools during their day-to-day work/hobby. In the beginning, formatters weren't even a thing. Now the majority of the projects \nout there have one.\n\nHowever, providing ALL these tools out of the box is a mastodontic challenge, and it has become the norm! Not just that, *sometimes* these tools are detached from the language. What does it mean? It means that, for example, linter and formatter are implemented by a different org/team of the main language.\n\n\u003Cimg src=\"https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTd0bnFyZHdnbnN0ZXU2ZjVmZXRjNDJ1eXgyemgzbzY5YTlpMmlmYSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/QMHoU66sBXqqLqYvGO/giphy.gif\" alt=\"This is fine meme\">\n\nThis fragmentation is very clear in JavaScript world, where the most famous linter, `eslint`, uses its own parser and logic to provide lint rules. Same for `prettier`, which uses its own parser and logic to provide formatting.\n\nIn fact, how much time have you spent setting linter, formatter, bundler, compiler, etc. inside a modern web code base?\n\n\u003Cimg src=\"https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3FycTBodWR3Yms4b3kwd2NjdHZ5Z3VzcmRzdDQ4dWc2NnY4Zjc4ZiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/BfiL8ZJWqfw7C/giphy.gif\" alt=\"Community fire meme\">\n\nA different story is `deno`, which provides a formatter out-of-the-box; however, it's detached from their toolchain. In fact, their formatting is done by `dprint`.\n\nYounger ecosystems such as [Go](https://go.dev/) and [Rust](https://rust-lang.org/) provide an all-in-one experience. Particularly, Go has its formatter baked in the source code of the language. Rust has its [`rustfmt`](https://github.com/rust-lang/rustfmt/) as part of the org, and uses the same parser of the compiler (still, it is detached from the compilation and the linting). \n\n### Knowledge base\n\nNow, try to guess which tool is the most challenging to implement? You would never believe it. I am sure that some of you answered the compiler. \nWell, the thing is, since the compiler is the most important thing for a language, there's a widespread knowledge of how to implement it. There are a lot of books, blogs, videos out there that can teach us how to craft one.\n\nYou see where I am going with this? Yes, **the formatter is the most difficult piece of software to implement**. In this piece of software there are very challenging problems to solve, however, since the \"formatter\" is a very low-key program, there isn't much knowledge base out there. \n\n[Bob Nystrom](https://bsky.app/profile/stuffwithstuff.com), writer of [Crafting Interpreters](https://craftinginterpreters.com/) [wrote about it when he wrote the Dart formatter](https://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/). Prettier creator, Christopher Chedeau, has recently created a blog post about the birth of Prettier, and talked about the [the challenges faced](https://blog.vjeux.com/2025/javascript/birth-of-prettier.html#:~:text=Printing%20Difficulties). \n\nAs co-creator of the Biome formatter, I can confirm that. My personal advice, if you ever want to write a formatter, is to use the Prettier + Biome architecture, which I believe works best for the majority of cases (wait for a blog post!). In fact, [Ruff](https://docs.astral.sh/ruff/) and [oxcfmt](https://oxc.rs/) use a fork of the Biome formatting infrastructure.\n\n## Takeaways \n\n**Toolchains are difficult**. We have clever people working on them, but don't take them for granted. \n\nDX across ecosystems is slowly improving, and we are learning from past mistakes. \n\nIt's great to see how the ecosystem is coming to an understanding, and try to meet the needs of the modern coding. **Toolchains are here to stay**.","src/content/blog/toolchain.md","0c00e95b284a14d3",{"html":23,"metadata":24},"\u003Ch2 id=\"whats-a-toolchain\" class=\"anchor\">What’s a toolchain?\u003Ca class=\"anchor-link\" href=\"#whats-a-toolchain\">#\u003C/a>\u003C/h2>\n\u003Cp>A toolchain is a common term to define software, most of the time a CLI, that provides a set of other tools.\u003C/p>\n\u003Cp>A toolchain that I know about is \u003Ca href=\"https://doc.rust-lang.org/cargo/\">\u003Ccode>cargo\u003C/code>\u003C/a>. \u003Ccode>cargo\u003C/code> is the official package manager of the Rust programming language,\nhowever \u003Ccode>cargo\u003C/code> provides other features:\u003C/p>\n\u003Cul>\n\u003Cli>formatter\u003C/li>\n\u003Cli>linter\u003C/li>\n\u003Cli>test runner\u003C/li>\n\u003Cli>task runner\u003C/li>\n\u003Cli>compiler\u003C/li>\n\u003Cli>…and more!\u003C/li>\n\u003C/ul>\n\u003Cp>The other features, \u003Cstrong>or tools\u003C/strong>, are essentially command line tools that are run by \u003Ccode>cargo\u003C/code>. I found \u003Ccode>cargo\u003C/code> to be very\npowerful, it offers a great developer experience, and it rarely has bugs (that I’m aware of!).\u003C/p>\n\u003Cp>The perception of toolchain may vary among ecosystems/languages. For example, the JavaScript/TypeScript ecosystem doesn’t have a\nproper toolchain like \u003Ccode>cargo\u003C/code>, but there are some libraries or frameworks that offer their version of “unified” toolchain:\u003C/p>\n\u003Cul>\n\u003Cli>For example \u003Ca href=\"https://docs.nestjs.com/cli/usages\">NestJs\u003C/a> offers its “toolchain” for the framework.\u003C/li>\n\u003Cli>Another example is \u003Ca href=\"https://docs.astro.build/en/reference/cli-reference/\">Astro\u003C/a>, which offers its “toolchain” to manage a project.\u003C/li>\n\u003Cli>Even \u003Ca href=\"https://nextjs.org/docs/pages/api-reference/cli/next\">Next.js\u003C/a> offers a “toolchain” to manage the project.\u003C/li>\n\u003C/ul>\n\u003Cimg class=\"prose\" src=\"https://gifdb.com/images/high/new-is-better-barney-stinson-h2b5mmth08rgleij.gif\" alt=\"New is always better\">\n\u003Cp>However, we can see the rise of other software that offers more powerful toolchains:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ca href=\"https://bun.sh/\">\u003Ccode>Bun\u003C/code>\u003C/a>: a runtime that offers a package manager, a bundler, a test runner, a task runner (probably more).\u003C/li>\n\u003Cli>\u003Ca href=\"https://deno.com/\">\u003Ccode>Deno\u003C/code>\u003C/a>: a runtime that offers a package manager, a bundler, a test runner, documentation generation, formatter, linter, a language server, a task runner (probably more).\u003C/li>\n\u003C/ul>\n\u003Cp>And \u003Ccode>Node.js\u003C/code> noticed this trend, and it started shipping toolchain capabilities such as test runner - via \u003Ccode>node:test\u003C/code> - and a task runner - via \u003Ccode>node run\u003C/code>.\u003C/p>\n\u003Cp>I’m generally happy with the trend of the JavaScript/TypeScript ecosystem, and we should keep borrowing ideas from new and modern languages/ecosystems.\u003C/p>\n\u003Ch2 id=\"the-hard-parts\" class=\"anchor\">The hard parts\u003Ca class=\"anchor-link\" href=\"#the-hard-parts\">#\u003C/a>\u003C/h2>\n\u003Cp>As maintainer of \u003Ca href=\"https://biomejs.dev\">Biome\u003C/a>, I’ve gained experience in how to write toolchains, and if there’s\nsomething that isn’t easy to get right, it’s the developer experience.\u003C/p>\n\u003Cp>Contrary to user experience, the developer experience is more subtle to get right because, as a specialist, you provide a tool to your peers who \u003Cem>should have the same level of knowledge\u003C/em>.\u003C/p>\n\u003Cp>Unfortunately, that’s not the case. Many of your peers come from different backgrounds and grades of knowledge. Even seniors will need to learn things from scratch. The DX (Developer Experience) of a toolchain must grow\nwith the knowledge acquired by your peers. Your users will always be “newbies”, and with time they will become proficient with the toolchain.\u003C/p>\n\u003Ch3 id=\"good-messages\" class=\"anchor\">Good messages\u003Ca class=\"anchor-link\" href=\"#good-messages\">#\u003C/a>\u003C/h3>\n\u003Cp>DX wasn’t a thing until ten years ago (more or less), so there wasn’t a focus on providing meaningful error messages. Most of the time, it’s still like this.\nLet’s take, for example, the following JavaScript snippet:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF79C6\">const\u003C/span>\u003Cspan style=\"color:#F8F8F2\"> something;\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>If you run it in your Browser (I tried Firefox), you’ll get the following message:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>Uncaught SyntaxError: missing = in const declaration\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>The message is somewhat understandable. However, I believe that this message is not beginner-friendly.\nLet’s see what Biome provides when parsing the same snippet:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan> at file.js:1:7 parse ━━━━━━━━━━━━━━━━━━━━\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ✖ Const declarations must have an initialized value.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 1 │ const something;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │       ^^^^^^^^^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ℹ This variable needs to be initialized.\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>This message explains that these kinds of declarations must be initialized, and it also shows where the error occurs.\u003C/p>\n\u003Cp>Let’s move to another example:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF79C6\">var\u003C/span>\u003Cspan style=\"color:#F8F8F2\"> foo \u003C/span>\u003Cspan style=\"color:#FF79C6\">=\u003C/span>\u003Cspan style=\"color:#F8F8F2\"> ;\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Here’s what the browser shows:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>Uncaught SyntaxError: expected expression, got ';'\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>And here’s what Biome outputs:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan> at file.js:1:11 parse ━━━━━━━━━━━━━━━━━━━━\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ✖ Expected an expression, or an assignment but instead found ';'.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 1 │ var foo = ;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │           ^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ℹ Expected an expression, or an assignment here.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 1 │ var foo = ;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │           ^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>I would admit that both messages provide the same level of value: both tell that they expect an expression. It’s not very beginner-friendly because the term “expression” is very technical. However, it’s also challenging to come up with a different message in this situation, especially a synonym for “expression”.\u003C/p>\n\u003Ch3 id=\"actionable-messages\" class=\"anchor\">Actionable messages\u003Ca class=\"anchor-link\" href=\"#actionable-messages\">#\u003C/a>\u003C/h3>\n\u003Cp>Providing actionable messages isn’t something easy to do when parsing broken code, so I will focus on the analysis part of the toolchain.\u003C/p>\n\u003Cp>What’s an “actionable message”? It’s a message that should explain to the user how to solve an error. Failing to provide an actionable message would risk making your user stuck, hence degrading the DX level of your toolchain.\u003C/p>\n\u003Cp>Let’s take, for example, the rule \u003Ca href=\"https://eslint.org/docs/latest/rules/require-await\">\u003Ccode>ESlint\u003C/code> \u003Ccode>require-await\u003C/code>\u003C/a>, and let’s compare it to the related \u003Ca href=\"https://oxc.rs/docs/guide/usage/linter/rules/eslint/require-await.html\">\u003Ccode>oxlint\u003C/code> rule\u003C/a>, and the \u003Ca href=\"https://biomejs.dev/linter/rules/use-await/\">Biome rule\u003C/a>\u003C/p>\n\u003Cp>We will lint the following snippet:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF79C6\">async\u003C/span>\u003Cspan style=\"color:#FF79C6\"> function\u003C/span>\u003Cspan style=\"color:#50FA7B\"> foo\u003C/span>\u003Cspan style=\"color:#F8F8F2\">() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#50FA7B\">    doSomething\u003C/span>\u003Cspan style=\"color:#F8F8F2\">();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F8F8F2\">}\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>This is the default diagnostic that \u003Ccode>ESLint\u003C/code> emits for the rule we’re interested in:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan> 1:1   error  Async function 'foo' has no 'await' expression  require-await\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>The message tells the user that something is missing, particularly that the code is missing an \u003Ccode>await\u003C/code> expression. Expression? Again??\u003C/p>\n\u003Cp>It doesn’t show where this \u003Ccode>foo\u003C/code> function is (maybe another reporter will show that to us), which forces us to check it inside the editor. However, the text \u003Ccode>1:1   error\u003C/code> provides a link to the file, which helps.\u003C/p>\n\u003Cp>Unfortunately, the message isn’t actionable because it doesn’t say how to solve the error.\u003C/p>\n\u003Cp>\u003Ccode>oxlint\u003C/code>, a younger \u003Ccode>ESLint\u003C/code>-compatible linter, takes a better approach:\u003C/p>\n\u003Cp>It does provide a frame of where the error occurred. Its message is actionable because it provides a tip on how the error could be solved.\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>  × eslint(require-await): Async function has no 'await' expression.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>   ╭─[file:///Users/ema/www/ematipico.xyz/file.js:1:16]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan> 1 │ async function foo() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>   ·                ───\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan> 2 │     doSomething();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>   ╰────\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  help: Consider removing the 'async' keyword.\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Biome, too, provides a good message:\u003C/p>\n\u003Cpre class=\"astro-code dracula\" style=\"background-color:#282A36;color:#F8F8F2; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan> at file.js:1:1 lint/suspicious/useAwait ━━━━━━━━━━━\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ⚠ This async function lacks an await expression.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 1 │ async function foo() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │ ^^^^^^^^^^^^^^^^^^^^^^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 2 │     doSomething();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 3 │ }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │ ^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ℹ Remove this async modifier, or add an await expression in the function.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 1 │ async function foo() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │ ^^^^^^^^^^^^^^^^^^^^^^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 2 │     doSomething();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  > 3 │ }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>      │ ^\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>  ℹ Async functions without await expressions may not need to be declared async\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>The rule also tries to explain why this is an error. It says that if you don’t use any \u003Ccode>await\u003C/code>, maybe the function shouldn’t be \u003Ccode>async\u003C/code> at all!\u003C/p>\n\u003Cp>Have you noticed the pattern here? If you haven’t, I tell you. \u003Ccode>ESLint\u003C/code>, an old tool, still struggles to provide meaningful DX, while younger software such as \u003Ccode>oxlint\u003C/code> and \u003Ccode>Biome\u003C/code> took the feedback from years of ranting, and elevated the DX to a better quality.\u003C/p>\n\u003Ch2 id=\"everything-out-of-the-box\" class=\"anchor\">Everything, out-of-the-box?\u003Ca class=\"anchor-link\" href=\"#everything-out-of-the-box\">#\u003C/a>\u003C/h2>\n\u003Cp>A toolchain can have different definitions in different ecosystems; however, nowadays, we’re reaching a heterogeneous definition: a toolchain should handle the lifecycle of a project.\u003C/p>\n\u003Cp>Based on the ecosystem, users expect different tools, and we can agree the majority of them require the following (order from most important, to least important, from my point of view):\u003C/p>\n\u003Col>\n\u003Cli>compiler/build/interpreter\u003C/li>\n\u003Cli>editor support\u003C/li>\n\u003Cli>linter\u003C/li>\n\u003Cli>formatter\u003C/li>\n\u003C/ol>\n\u003Cp>Let’s see how these tools are distributed.\u003C/p>\n\u003Ch3 id=\"fragmentation\" class=\"anchor\">Fragmentation\u003Ca class=\"anchor-link\" href=\"#fragmentation\">#\u003C/a>\u003C/h3>\n\u003Cp>With the evolution of coding, developers discovered that they require more tools during their day-to-day work/hobby. In the beginning, formatters weren’t even a thing. Now the majority of the projects\nout there have one.\u003C/p>\n\u003Cp>However, providing ALL these tools out of the box is a mastodontic challenge, and it has become the norm! Not just that, \u003Cem>sometimes\u003C/em> these tools are detached from the language. What does it mean? It means that, for example, linter and formatter are implemented by a different org/team of the main language.\u003C/p>\n\u003Cimg src=\"https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTd0bnFyZHdnbnN0ZXU2ZjVmZXRjNDJ1eXgyemgzbzY5YTlpMmlmYSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/QMHoU66sBXqqLqYvGO/giphy.gif\" alt=\"This is fine meme\">\n\u003Cp>This fragmentation is very clear in JavaScript world, where the most famous linter, \u003Ccode>eslint\u003C/code>, uses its own parser and logic to provide lint rules. Same for \u003Ccode>prettier\u003C/code>, which uses its own parser and logic to provide formatting.\u003C/p>\n\u003Cp>In fact, how much time have you spent setting linter, formatter, bundler, compiler, etc. inside a modern web code base?\u003C/p>\n\u003Cimg src=\"https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3FycTBodWR3Yms4b3kwd2NjdHZ5Z3VzcmRzdDQ4dWc2NnY4Zjc4ZiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/BfiL8ZJWqfw7C/giphy.gif\" alt=\"Community fire meme\">\n\u003Cp>A different story is \u003Ccode>deno\u003C/code>, which provides a formatter out-of-the-box; however, it’s detached from their toolchain. In fact, their formatting is done by \u003Ccode>dprint\u003C/code>.\u003C/p>\n\u003Cp>Younger ecosystems such as \u003Ca href=\"https://go.dev/\">Go\u003C/a> and \u003Ca href=\"https://rust-lang.org/\">Rust\u003C/a> provide an all-in-one experience. Particularly, Go has its formatter baked in the source code of the language. Rust has its \u003Ca href=\"https://github.com/rust-lang/rustfmt/\">\u003Ccode>rustfmt\u003C/code>\u003C/a> as part of the org, and uses the same parser of the compiler (still, it is detached from the compilation and the linting).\u003C/p>\n\u003Ch3 id=\"knowledge-base\" class=\"anchor\">Knowledge base\u003Ca class=\"anchor-link\" href=\"#knowledge-base\">#\u003C/a>\u003C/h3>\n\u003Cp>Now, try to guess which tool is the most challenging to implement? You would never believe it. I am sure that some of you answered the compiler.\nWell, the thing is, since the compiler is the most important thing for a language, there’s a widespread knowledge of how to implement it. There are a lot of books, blogs, videos out there that can teach us how to craft one.\u003C/p>\n\u003Cp>You see where I am going with this? Yes, \u003Cstrong>the formatter is the most difficult piece of software to implement\u003C/strong>. In this piece of software there are very challenging problems to solve, however, since the “formatter” is a very low-key program, there isn’t much knowledge base out there.\u003C/p>\n\u003Cp>\u003Ca href=\"https://bsky.app/profile/stuffwithstuff.com\">Bob Nystrom\u003C/a>, writer of \u003Ca href=\"https://craftinginterpreters.com/\">Crafting Interpreters\u003C/a> \u003Ca href=\"https://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/\">wrote about it when he wrote the Dart formatter\u003C/a>. Prettier creator, Christopher Chedeau, has recently created a blog post about the birth of Prettier, and talked about the \u003Ca href=\"https://blog.vjeux.com/2025/javascript/birth-of-prettier.html#:~:text=Printing%20Difficulties\">the challenges faced\u003C/a>.\u003C/p>\n\u003Cp>As co-creator of the Biome formatter, I can confirm that. My personal advice, if you ever want to write a formatter, is to use the Prettier + Biome architecture, which I believe works best for the majority of cases (wait for a blog post!). In fact, \u003Ca href=\"https://docs.astral.sh/ruff/\">Ruff\u003C/a> and \u003Ca href=\"https://oxc.rs/\">oxcfmt\u003C/a> use a fork of the Biome formatting infrastructure.\u003C/p>\n\u003Ch2 id=\"takeaways\" class=\"anchor\">Takeaways\u003Ca class=\"anchor-link\" href=\"#takeaways\">#\u003C/a>\u003C/h2>\n\u003Cp>\u003Cstrong>Toolchains are difficult\u003C/strong>. We have clever people working on them, but don’t take them for granted.\u003C/p>\n\u003Cp>DX across ecosystems is slowly improving, and we are learning from past mistakes.\u003C/p>\n\u003Cp>It’s great to see how the ecosystem is coming to an understanding, and try to meet the needs of the modern coding. \u003Cstrong>Toolchains are here to stay\u003C/strong>.\u003C/p>",{"headings":25,"localImagePaths":52,"remoteImagePaths":53,"frontmatter":54,"imagePaths":56},[26,30,33,37,40,43,46,49],{"depth":27,"slug":28,"text":29},2,"whats-a-toolchain","What’s a toolchain?#",{"depth":27,"slug":31,"text":32},"the-hard-parts","The hard parts#",{"depth":34,"slug":35,"text":36},3,"good-messages","Good messages#",{"depth":34,"slug":38,"text":39},"actionable-messages","Actionable messages#",{"depth":27,"slug":41,"text":42},"everything-out-of-the-box","Everything, out-of-the-box?#",{"depth":34,"slug":44,"text":45},"fragmentation","Fragmentation#",{"depth":34,"slug":47,"text":48},"knowledge-base","Knowledge base#",{"depth":27,"slug":50,"text":51},"takeaways","Takeaways#",[],[],{"title":14,"description":15,"pubDate":55,"heroImage":17,"heroAltImage":18,"slug":11},["Date","2025-10-10T00:00:00.000Z"],[],"projects",["Map",59,60,70,71,79,80,88,89,97,98],"biome",{"id":59,"data":61,"filePath":69},{"id":59,"name":62,"description":63,"githubUrl":64,"website":65,"iconUrl":66,"contributions":67,"order":68},"Biome","A toolchain for web projects, aimed to provide functionality of many separate tools. Successor to Rome","https://github.com/biomejs/biome","https://biomejs.dev","https://github.com/biomejs.png","I am the creator and lead of the project. I contributed to different parts of the projects, such as the CLI, the LSP, many lint rules, and the formatter.",1,"src/content/projects.json","astro",{"id":70,"data":72,"filePath":69},{"id":70,"name":73,"description":74,"githubUrl":75,"website":76,"iconUrl":77,"contributions":78,"order":27},"Astro","The web framework for content-driven websites","https://github.com/withastro/astro","https://astro.build","https://github.com/withastro.png","I am currently part of the Core Team. I contributed to the project by implementing the middleware feature, and the edge middleware system for some the official adapters. New build system, i18n and CSP.","webpack",{"id":79,"data":81,"filePath":69},{"id":79,"name":82,"description":83,"githubUrl":84,"website":85,"iconUrl":86,"contributions":87,"order":34},"Webpack","A static module bundler for modern JavaScript applications","https://github.com/webpack/webpack","https://webpack.js.org","https://github.com/webpack.png","","standard",{"id":88,"data":90,"filePath":69},{"id":88,"name":91,"description":92,"githubUrl":93,"website":94,"iconUrl":95,"contributions":87,"order":96},"Standard","JavaScript Standard Style - One style to rule them all","https://github.com/standard/standard","https://standardjs.com","https://github.com/standard.png",4,"rome",{"id":97,"data":99,"filePath":69},{"id":97,"name":100,"description":101,"githubUrl":102,"iconUrl":103,"contributions":87,"order":104},"Rome","A toolchain for web projects, aimed to provide functionality of many separate tools","https://github.com/rome/tools","https://github.com/rome.png",5]